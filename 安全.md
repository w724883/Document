- xss

通过在页面拼接js代码，如

```html
<a href="/user/1"><script>alert(1)</script></a>

<img src="javascript:alert('XSS');" onerror="alert(1)">

<script>var user_data = {"exploit": "</script><script>alert(1);//"};</script>

<INPUT type="text" value='><SCRIPT>alert("XSS")</SCRIPT><xssa=''/>

<BODY onload="alert('XSS')">

<link rel="stylesheet" href="javascript：alert('XSS');">

<div style="width:expression(alert('XSS'));">
```

解决：

1.在合适的地方使用转义

2.不要相信来自用户的输入，过滤（不仅限于 POST Body，还包括 QueryString，甚至是 Headers）

- csrf

跨域伪造请求，使用户做出非本意的行为

1.通过代理发送请求

2.通过form表单提交请求

解决：

1.给所有请求加上 token 检查。token是随机字符串，只需确保其不可预测性即可。token 可以在 QueryString、POST body 甚至是 Custom Header 里，但千万不能在 Cookies 里。

检查 referer （请注意，这往往不能防御来自网站自身的 CSRF 攻击，如用户评论中的 <img> 就是一个常见触发点），ajax请求也能修改referer

- SQL 注入

通过在后端拼接sql代码，如

```sql
SELECT * FROM USERS WHERE UserName="";DROP TABLE USERS;--"
```

解决：

1.使用参数化查询，把所有变量作为参数，数据库不会将参数作为SQL指令处理

2.使用预编译

3.过滤变量中的指令

- 权限控制漏洞

后端代码不严谨，没有做校验


- 会话劫持

SESSION 与 COOKIE泄漏，导致其他用户得到与服务器的会话权限

- 中间人劫持（路由劫持、DNS劫持）

链接免费wifi时，路由器提供一个特殊的dns服务，将所有的域名都解析到我们的电脑，并将wifi的dhcp-dns设置为电脑ip，其实就是抓包的原理。
我们可以拿到明文数据包，并且对数据包进行加工，比如插入脚本。

https 使用的是 443 端口进行数据传输，而浏览器的默认端口是 80. 劫持者首先劫持用户的 80 端口，当用户向目标页发起请求时，劫持者模拟正常的 https 请求向源服务器获取数据，然后通过 80 端口返回给用户。

强制客户端使用 HTTPS 访问页面。其原理就是：

启用HSTS，在服务器响应头中添加 Strict-Transport-Security，可以设置 max-age

用户访问时，服务器种下这个头

下次如果使用 http 访问，只要 max-age 未过期，客户端会进行内部跳转，可以看到 307 Redirect Internel 的响应码，变成 https 访问源服务器

HSTS存在的问题：

纯 IP 的请求，HSTS 没法处理，比如 http://2.2.2.2 ， 即便响应头中设置了 STS，浏览器也不会理会（未测试）

HSTS 只能在 80 和 443 端口之间切换，如果服务是 8080 端口，即便设置了 STS，也无效（未测试）

如果浏览器证书错误，一般情况会提醒存在安全风险，然是依然给一个链接进入目标页，而 HSTS 则没有目标页入口，所以一旦证书配置错误，就是很大的故障了

如果服务器的 HTTPS 没有配置好就开启了 STS 的响应头，并且还设置了很长的过期时间，那么在你服务器 HTTPS 配置好之前，用户都是没办法连接到你的服务器的，除非 max-age 过期了。

HSTS 能让你的网站在 ssllab 上到 A+（这不是坑）
